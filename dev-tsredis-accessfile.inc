<?PHP
// This implementation uses phpredis library AND tsredic client part lib
// Liba has only one usage - by daemon which regenetaring HA acces file with paths to redis running


// watch '' needed or NULL in $redis_host, $redis_host_write needed
function write_accessfile($redis_accessfile, $redis_host, $redis_host_write, $cancel_if_exists=TRUE) {
	if ($cancel_if_exists && file_exists($redis_accessfile)) return(TRUE);
	$file="<?PHP
// Do not modify, periodically autogenerated from main config and servers state
$redis_host=$redis_host;
$redis_host_write=$redis_host_write;
?>";
	if (file_exists($redis_accessfile && file_get_contents($redis_accessfile)==$file)) {
		tolog("REDIS accessfile $redis_accessfile unchanged, no need to write", L_DEBUG);
		return(TRUE);
	}
	if (file_put_contents($redis_accessfile.'new', $file)===FALSE) {
		tolog("redis accessfile $redis_accessfile unwriteble, aborting generation", L_ERR);
		return(FALSE);
	}
	rename($redis_accessfile.'new', $redis_accessfile);
}

function get_master($connection, &$master) {
	$servers=$test->info('REPLICATION');
	switch ($rervers['role']) {
		case 'master':
			$master=TRUE;
			return(TRUE);
		case 'slave':
			$master="$rervers[master_host]:$rervers[master_port]";
			return(TRUE);			
		default:
			tolog("unknown REDIS server role: $rervers[role]", L_ERR);
			$master=NULL;
			return(FALSE);
	}
}
	
function regenerate_accessfile() {
	global $redis, $redis_host, $redis_host_write, $redis_write, $redis_host_write, $redis_pass_write, $redis_accessfile, $redis_nodelist, $redis_mode;
	switch ($redis_mode) {
		case 'default':
		case 'standalone':
		case 'cluster':
		default:
			tolog("REDIS mode $redis_mode is not supported properly, consider change to replication", L_WARN);
			if (!$redis_host) {
				tolog("redis_host not set in config, can't continue", L_ERR);
				return(FALSE);
			}
			if ($redis_host_write) $wr="'$redis_host_write:6379'"; else $wr='NULL';
			write_accessfile($redis_accessfile, "'$redis_host:6379'", $wr, TRUE);
			break;
		case 'replication':
			connect_redis();
			if ($redis && get_master($redis, $master)) { // if current redis is connectable, give it priority
				if ($master===TRUE) $master="'$redis_host:6379'";
				tolog ("regenerate_accessfile: current $redis_host will remain, redis_host_write is $master", L_INFO);
				write_accessfile($redis_accessfile, "'$redis_host:6379'", $master, FALSE);
			}
				
			if (!is_array($redis_nodelist)) tolog('$redis_nodelist not properly defined in master config', L_ERR | L_DIE);
			if (isset($redis_host) && $redis_host) {
				list($h, $p)=explode(':', $redis_host);
				if (!isset($redis_nodelist[$h])) $redis_nodelist[$h]=array('port' => $p);
			}
			if (isset($redis_host_write) && $redis_host_write) {
				list($h, $p)=explode(':', $redis_host_write);
				if (!isset($redis_nodelist[$h])) $redis_nodelist[$h]=array('port' => $p);
			}
			$variants=array();
			foreach ($redis_nodelist as $h => $node) {
				$test=new Redis();
				$test->pconnect($h, $node['port'], 1, NULL, 100); // 1s timeout, 100ms between attempts
				if ($redis_pass) $test->auth($redis_pass); // ignore result to prevent case with auth to free server
				if (get_master($test, $master)) {
					$node['prio']=$node['prio'] ?? 100;
					$node['prob']=$node['prob'] ?? 100;
					$variants[$node['prio']]["$h:$node[port]"]=array('h'=>"$h:$node[port]", 'm'=>$master, 'prob' => $prob);
				}
			}
			if (!count($variants)) {
				tolog("FATAL: No reachable REDIS server, stopping accessfile generation");
				return(FALSE);
			}
			ksort($variants);
			$prio_variants=array();
			$old_prio=0;
			$sum_prob=0;
			$i=0;
			foreach($variants as $prio=>$v) {
				if ($prio && $old_prio!=$prio) break;
				$prio_variants[$i]=array('f'=>$sum_prob, 't'=>$sum_prob+$v['prob'], 'h'=>$v['h'], 'm'=>$v['m']);
				$sum_prob+=$v['prob'];
			}
			$sel=rand(0, $sum_prob);
			foreach($prio_variants as $v) 
				if ($sel>=$v['f'] && $sel<=$v['t']) {
					tolog ("regenerate_accessfile: selected $v[h], redis_host_write is $v[m]", L_INFO);
					write_accessfile($redis_accessfile, "'$v[h]'", "'$v[m]'", FALSE);
				}
			break;
	}				
}
	